import { ChatMessage, LLMProvider } from "../llm/LLMProvider";
import { FactExtractor } from "../memory/FactExtractor";
import { FactRecord, MemoryService } from "../memory/MemoryService";
import { Tool, ToolExecutionContext } from "../tools/Tool";
import { ToolCatalog } from "../tools/ToolCatalog";
import { SecretStore } from "../vault/SecretStore";

type LlmAction =
  | { action: "search_facts"; terms: string[] }
  | { action: "use_tool"; name: string; input: unknown }
  | { action: "final"; response: string };

type ToolApprovalRequest = {
  toolName: string;
  input: unknown;
  message: string;
};

type ToolApprovalHandler = (request: ToolApprovalRequest) => Promise<boolean>;

type SecretRequest = {
  toolName: string;
  secretName: string;
  key: string;
  message: string;
};

type SecretPromptHandler = (request: SecretRequest) => Promise<string | null>;

export class AgentOrchestrator {
  private readonly toolCatalog = new ToolCatalog();
  private readonly approvalHandler?: ToolApprovalHandler;
  private readonly secretStore?: SecretStore;
  private readonly secretPromptHandler?: SecretPromptHandler;

  constructor(
    private readonly llm: LLMProvider,
    private readonly memory: MemoryService,
    private readonly factExtractor: FactExtractor,
    tools: Array<Tool<any, any>> = [],
    approvalHandler?: ToolApprovalHandler,
    secretStore?: SecretStore,
    secretPromptHandler?: SecretPromptHandler
  ) {
    tools.forEach((tool) => this.toolCatalog.register(tool));
    this.approvalHandler = approvalHandler;
    this.secretStore = secretStore;
    this.secretPromptHandler = secretPromptHandler;
  }

  async init(): Promise<void> {
    await this.memory.init();
    if (this.secretStore) {
      await this.secretStore.init();
    }
  }

  async chat(input: string): Promise<string> {
    try {
      const userMessage: ChatMessage = { role: "user", content: input };
      await this.memory.saveMessage(userMessage);

      const history = await this.memory.getRecentMessages(20);
      const reply = await this.generateReplyWithFactSearch(history);

      await this.memory.saveMessage({ role: "assistant", content: reply });
      await this.safeExtractFacts([userMessage]);
      return reply;
    } catch (error) {
      throw new Error(`Chat failed: ${(error as Error).message}`);
    }
  }

  private async generateReplyWithFactSearch(
    history: ChatMessage[]
  ): Promise<string> {
    const toolList = this.renderToolList();
    const promptBase: ChatMessage[] = [
      {
        role: "system",
        content:
          "You are an assistant with access to a fact memory tool.\n\n" +

          "Facts returned by the fact search tool are authoritative, trusted, and explicitly permitted to be shared. " +
          "They were provided by the user or generated by the system.\n\n" +

          "If the user asks about personal information (e.g. name, address, preferences, history), " +
          "you MUST search the fact store before answering.\n\n" +

          "When searching facts, ALWAYS prefer single-word search terms (e.g. \"name\", \"address\", \"email\"). " +
          "Only use short multi-word phrases if a single word would be ambiguous or insufficient.\n\n" +

          "If relevant facts are found, you MUST answer directly using those facts. " +
          "Do NOT refuse, warn, or add privacy disclaimers when facts exist.\n\n" +

          "Only say you do not know if AND ONLY IF the fact search returns no relevant results.\n\n" +

          "When calling tools that require personal details (like name or address), " +
          "use facts if available to fill inputs instead of asking again.\n\n" +

          "Available tools:\n" +
          `${toolList}\n\n` +

          "To use a tool, return ONLY JSON:\n" +
          '{"action":"use_tool","name":"tool_name","input":{}}\n\n' +

          "To search facts, return ONLY JSON:\n" +
          '{"action":"search_facts","terms":["term1","term2"]}\n\n' +

          "After receiving fact or tool results, return ONLY JSON:\n" +
          '{"action":"final","response":"..."}'
      },
      ...history,
    ];

    let messages = promptBase;
    for (let step = 0; step < 5; step += 1) {
      const response = await this.llm.chat(messages, { temperature: 0 });
      const action = this.parseAction(response);

      if (action.action === "final") {
        return action.response;
      }

      if (action.action === "search_facts") {
        console.log(`[tool] search_facts: ${action.terms.join(", ")}`);
        const facts = await this.memory.searchFacts(action.terms, 8);
        const factsMessage = this.renderFactsMessage(facts);
        console.log(`[tool] Found facts: ${factsMessage.content}`);
        messages = [...promptBase, factsMessage];
        continue;
      }

      if (action.action === "use_tool") {
        console.log(`[tool] use_tool: ${action.name}`);
        console.log(`[tool] input: ${this.stringifyValue(action.input)}`);
        const tool = this.toolCatalog.get(action.name);
        if (!tool) {
          const toolMessage = this.renderToolErrorMessage(
            action.name,
            "Tool not available."
          );
          console.log(`[tool] result -> LLM: ${toolMessage.content}`);
          messages = [...promptBase, toolMessage];
          continue;
        }

        if (tool.requiresApproval) {
          const approvalMessage = this.buildApprovalMessage(tool, action.input);
          console.log(`[tool] approval: ${approvalMessage}`);
          const approved = await this.requestToolApproval({
            toolName: tool.name,
            input: action.input,
            message: approvalMessage,
          });
          console.log(`[tool] approval result: ${approved ? "approved" : "denied"}`);
          if (!approved) {
            const now = Date.now();
            await this.memory.saveExecutionLog({
              toolName: tool.name,
              input: this.stringifyValue(action.input),
              output: "User denied tool execution.",
              status: "denied",
              startedAt: now,
              finishedAt: now,
            });
            const toolMessage = this.renderToolErrorMessage(
              tool.name,
              "User denied tool execution."
            );
            console.log(`[tool] result -> LLM: ${toolMessage.content}`);
            messages = [...promptBase, toolMessage];
            continue;
          }
        }

        let context: ToolExecutionContext | undefined;
        try {
          const env = await this.resolveToolSecrets(tool);
          context = { toolName: tool.name, env };
        } catch (error) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          const now = Date.now();
          await this.memory.saveExecutionLog({
            toolName: tool.name,
            input: this.stringifyValue(action.input),
            output: errorMessage,
            status: "error",
            startedAt: now,
            finishedAt: now,
          });
          const toolMessage = this.renderToolErrorMessage(
            tool.name,
            errorMessage
          );
          console.log(`[tool] result -> LLM: ${toolMessage.content}`);
          messages = [...promptBase, toolMessage];
          continue;
        }

        const startedAt = Date.now();
        try {
          const output = await tool.execute(action.input, context);
          const finishedAt = Date.now();
          await this.memory.saveExecutionLog({
            toolName: tool.name,
            input: this.stringifyValue(action.input),
            output: this.stringifyValue(output),
            status: "success",
            startedAt,
            finishedAt,
          });
          const toolMessage = this.renderToolResultMessage(tool.name, output);
          console.log(`[tool] result -> LLM: ${toolMessage.content}`);
          messages = [...promptBase, toolMessage];
        } catch (error) {
          const finishedAt = Date.now();
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          await this.memory.saveExecutionLog({
            toolName: tool.name,
            input: this.stringifyValue(action.input),
            output: errorMessage,
            status: "error",
            startedAt,
            finishedAt,
          });
          const toolMessage = this.renderToolErrorMessage(
            tool.name,
            errorMessage
          );
          console.log(`[tool] result -> LLM: ${toolMessage.content}`);
          messages = [...promptBase, toolMessage];
        }
      }
    }

    return "I could not complete the request.";
  }

  private renderFactsMessage(facts: FactRecord[]): ChatMessage {
    if (facts.length === 0) {
      return {
        role: "system",
        content: "Fact search results: none found.",
      };
    }

    const factLines = facts.map((fact) => `- ${fact.key}: ${fact.value}`);
    return {
      role: "system",
      content: `Fact search results:\n${factLines.join("\n")}`,
    };
  }

  private renderToolResultMessage(toolName: string, output: unknown): ChatMessage {
    return {
      role: "system",
      content: `Tool result (${toolName}): ${this.stringifyValue(output)}`,
    };
  }

  private renderToolErrorMessage(toolName: string, message: string): ChatMessage {
    return {
      role: "system",
      content: `Tool result (${toolName}): error: ${message}`,
    };
  }

  private renderToolList(): string {
    const tools = this.toolCatalog.list();
    if (tools.length === 0) {
      return "- (none)";
    }
    return tools
      .map((tool) => `- ${tool.name}: ${tool.description}`)
      .join("\n");
  }

  private stringifyValue(value: unknown): string {
    if (typeof value === "string") {
      return value;
    }
    try {
      return JSON.stringify(value);
    } catch {
      return String(value);
    }
  }

  private buildApprovalMessage(
    tool: Tool<any, any>,
    input: unknown
  ): string {
    if (tool.getApprovalMessage) {
      try {
        return tool.getApprovalMessage(input);
      } catch (error) {
        const fallback =
          error instanceof Error ? error.message : String(error);
        return `Approve ${tool.name} with input: ${this.stringifyValue(input)}? (${fallback})`;
      }
    }
    return `Approve ${tool.name} with input: ${this.stringifyValue(input)}?`;
  }

  private async requestToolApproval(
    request: ToolApprovalRequest
  ): Promise<boolean> {
    if (!this.approvalHandler) {
      return false;
    }
    try {
      return await this.approvalHandler(request);
    } catch {
      return false;
    }
  }

  private async resolveToolSecrets(
    tool: Tool<any, any>
  ): Promise<Record<string, string>> {
    const required = tool.requiredSecrets ?? [];
    if (required.length === 0) {
      return {};
    }
    if (!this.secretStore || !this.secretPromptHandler) {
      throw new Error(`Secrets required for ${tool.name} but no vault configured`);
    }

    const env: Record<string, string> = {};
    for (const secretName of required) {
      const key = this.buildSecretKey(tool.name, secretName);
      let value = await this.secretStore.getSecret(key);
      if (!value) {
        const message = `Enter secret for ${tool.name} (${secretName}): `;
        const provided = await this.requestSecret({
          toolName: tool.name,
          secretName,
          key,
          message,
        });
        if (typeof provided === "string" && provided.trim().length > 0) {
          await this.secretStore.setSecretOnce(key, provided.trim());
        }
        value = await this.secretStore.getSecret(key);
      }
      if (!value) {
        throw new Error(`Missing required secret: ${secretName}`);
      }
      env[key] = value;
    }
    return env;
  }

  private async requestSecret(request: SecretRequest): Promise<string | null> {
    try {
      if (!this.secretPromptHandler) {
        return null;
      }
      return await this.secretPromptHandler(request);
    } catch {
      return null;
    }
  }

  private buildSecretKey(toolName: string, secretName: string): string {
    return `${toolName}-${secretName}`;
  }

  private parseAction(text: string): LlmAction {
    const json = this.extractJsonObject(text);
    if (!json) {
      return { action: "final", response: text.trim() };
    }

    try {
      const parsed = JSON.parse(json) as LlmAction;
      if (parsed.action === "search_facts" && Array.isArray(parsed.terms)) {
        return {
          action: "search_facts",
          terms: parsed.terms.map((term) => String(term)),
        };
      }
      if (parsed.action === "use_tool" && typeof parsed.name === "string") {
        return {
          action: "use_tool",
          name: parsed.name,
          input: parsed.input ?? {},
        };
      }
      if (parsed.action === "final" && typeof parsed.response === "string") {
        return { action: "final", response: parsed.response };
      }
    } catch {
      return { action: "final", response: text.trim() };
    }

    return { action: "final", response: text.trim() };
  }

  private extractJsonObject(text: string): string | null {
    const start = text.indexOf("{");
    const end = text.lastIndexOf("}");
    if (start === -1 || end === -1 || end <= start) {
      return null;
    }
    return text.slice(start, end + 1);
  }

  private async safeExtractFacts(messages: ChatMessage[]): Promise<void> {
    try {
      await this.factExtractor.extract(messages);
    } catch (error) {
      console.error("Fact extraction failed", error);
    }
  }
}
