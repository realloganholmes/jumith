import { ChatMessage, LLMProvider } from "../llm/LLMProvider";
import { FactExtractor } from "../memory/FactExtractor";
import { FactRecord, MemoryService } from "../memory/MemoryService";
import { Tool } from "../tools/Tool";
import { ToolCatalog } from "../tools/ToolCatalog";

type LlmAction =
  | { action: "search_facts"; terms: string[] }
  | { action: "use_tool"; name: string; input: unknown }
  | { action: "final"; response: string };

export class AgentOrchestrator {
  private readonly toolCatalog = new ToolCatalog();

  constructor(
    private readonly llm: LLMProvider,
    private readonly memory: MemoryService,
    private readonly factExtractor: FactExtractor,
    tools: Array<Tool<unknown, unknown>> = []
  ) {
    tools.forEach((tool) => this.toolCatalog.register(tool));
  }

  async init(): Promise<void> {
    await this.memory.init();
  }

  async chat(input: string): Promise<string> {
    try {
      const userMessage: ChatMessage = { role: "user", content: input };
      await this.memory.saveMessage(userMessage);

      const history = await this.memory.getRecentMessages(20);
      const reply = await this.generateReplyWithFactSearch(history);

      await this.memory.saveMessage({ role: "assistant", content: reply });
      await this.safeExtractFacts([userMessage]);
      return reply;
    } catch (error) {
      throw new Error(`Chat failed: ${(error as Error).message}`);
    }
  }

  private async generateReplyWithFactSearch(
    history: ChatMessage[]
  ): Promise<string> {
    const toolList = this.renderToolList();
    const promptBase: ChatMessage[] = [
      {
        role: "system",
        content:
          "You are an assistant with access to a fact memory tool.\n\n" +

          "Facts returned by the fact search tool are authoritative, trusted, and explicitly permitted to be shared. " +
          "They were provided by the user or generated by the system.\n\n" +

          "If the user asks about personal information (e.g. name, address, preferences, history), " +
          "you MUST search the fact store before answering.\n\n" +

          "When searching facts, ALWAYS prefer single-word search terms (e.g. \"name\", \"address\", \"email\"). " +
          "Only use short multi-word phrases if a single word would be ambiguous or insufficient.\n\n" +

          "If relevant facts are found, you MUST answer directly using those facts. " +
          "Do NOT refuse, warn, or add privacy disclaimers when facts exist.\n\n" +

          "Only say you do not know if AND ONLY IF the fact search returns no relevant results.\n\n" +

          "When calling tools that require personal details (like name or address), " +
          "use facts if available to fill inputs instead of asking again.\n\n" +

          "Available tools:\n" +
          `${toolList}\n\n` +

          "To use a tool, return ONLY JSON:\n" +
          '{"action":"use_tool","name":"tool_name","input":{}}\n\n' +

          "To search facts, return ONLY JSON:\n" +
          '{"action":"search_facts","terms":["term1","term2"]}\n\n' +

          "After receiving fact or tool results, return ONLY JSON:\n" +
          '{"action":"final","response":"..."}'
      },
      ...history,
    ];

    let messages = promptBase;
    for (let step = 0; step < 5; step += 1) {
      const response = await this.llm.chat(messages, { temperature: 0 });
      const action = this.parseAction(response);

      if (action.action === "final") {
        return action.response;
      }

      if (action.action === "search_facts") {
        console.log(`[tool] search_facts: ${action.terms.join(", ")}`);
        const facts = await this.memory.searchFacts(action.terms, 8);
        const factsMessage = this.renderFactsMessage(facts);
        console.log(`[tool] Found facts: ${factsMessage.content}`);
        messages = [...promptBase, factsMessage];
        continue;
      }

      if (action.action === "use_tool") {
        console.log(`[tool] use_tool: ${action.name}`);
        console.log(`[tool] input: ${this.stringifyValue(action.input)}`);
        const tool = this.toolCatalog.get(action.name);
        if (!tool) {
          const toolMessage = this.renderToolErrorMessage(
            action.name,
            "Tool not available."
          );
          console.log(`[tool] result -> LLM: ${toolMessage.content}`);
          messages = [...promptBase, toolMessage];
          continue;
        }

        const startedAt = Date.now();
        try {
          const output = await tool.execute(action.input);
          const finishedAt = Date.now();
          await this.memory.saveExecutionLog({
            toolName: tool.name,
            input: this.stringifyValue(action.input),
            output: this.stringifyValue(output),
            status: "success",
            startedAt,
            finishedAt,
          });
          const toolMessage = this.renderToolResultMessage(tool.name, output);
          console.log(`[tool] result -> LLM: ${toolMessage.content}`);
          messages = [...promptBase, toolMessage];
        } catch (error) {
          const finishedAt = Date.now();
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          await this.memory.saveExecutionLog({
            toolName: tool.name,
            input: this.stringifyValue(action.input),
            output: errorMessage,
            status: "error",
            startedAt,
            finishedAt,
          });
          const toolMessage = this.renderToolErrorMessage(
            tool.name,
            errorMessage
          );
          console.log(`[tool] result -> LLM: ${toolMessage.content}`);
          messages = [...promptBase, toolMessage];
        }
      }
    }

    return "I could not complete the request.";
  }

  private renderFactsMessage(facts: FactRecord[]): ChatMessage {
    if (facts.length === 0) {
      return {
        role: "system",
        content: "Fact search results: none found.",
      };
    }

    const factLines = facts.map((fact) => `- ${fact.key}: ${fact.value}`);
    return {
      role: "system",
      content: `Fact search results:\n${factLines.join("\n")}`,
    };
  }

  private renderToolResultMessage(toolName: string, output: unknown): ChatMessage {
    return {
      role: "system",
      content: `Tool result (${toolName}): ${this.stringifyValue(output)}`,
    };
  }

  private renderToolErrorMessage(toolName: string, message: string): ChatMessage {
    return {
      role: "system",
      content: `Tool result (${toolName}): error: ${message}`,
    };
  }

  private renderToolList(): string {
    const tools = this.toolCatalog.list();
    if (tools.length === 0) {
      return "- (none)";
    }
    return tools
      .map((tool) => `- ${tool.name}: ${tool.description}`)
      .join("\n");
  }

  private stringifyValue(value: unknown): string {
    if (typeof value === "string") {
      return value;
    }
    try {
      return JSON.stringify(value);
    } catch {
      return String(value);
    }
  }

  private parseAction(text: string): LlmAction {
    const json = this.extractJsonObject(text);
    if (!json) {
      return { action: "final", response: text.trim() };
    }

    try {
      const parsed = JSON.parse(json) as LlmAction;
      if (parsed.action === "search_facts" && Array.isArray(parsed.terms)) {
        return {
          action: "search_facts",
          terms: parsed.terms.map((term) => String(term)),
        };
      }
      if (parsed.action === "use_tool" && typeof parsed.name === "string") {
        return {
          action: "use_tool",
          name: parsed.name,
          input: parsed.input ?? {},
        };
      }
      if (parsed.action === "final" && typeof parsed.response === "string") {
        return { action: "final", response: parsed.response };
      }
    } catch {
      return { action: "final", response: text.trim() };
    }

    return { action: "final", response: text.trim() };
  }

  private extractJsonObject(text: string): string | null {
    const start = text.indexOf("{");
    const end = text.lastIndexOf("}");
    if (start === -1 || end === -1 || end <= start) {
      return null;
    }
    return text.slice(start, end + 1);
  }

  private async safeExtractFacts(messages: ChatMessage[]): Promise<void> {
    try {
      await this.factExtractor.extract(messages);
    } catch (error) {
      console.error("Fact extraction failed", error);
    }
  }
}
